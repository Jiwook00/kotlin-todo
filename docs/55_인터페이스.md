## μΈν„°νμ΄μ¤ (Interface)
μΈν„°νμ΄μ¤(interface)λ” νƒ€μ…(type)μ΄λΌλ” κ°λ…μ„ κΈ°μ ν•λ‹¤. μΈν„°νμ΄μ¤λ” κ·Έ μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” λ¨λ“  ν΄λμ¤μ ν”„λ΅ν† νƒ€μ…(prototype)μ΄λ‹¤.

### AtomicKotlinCourseμ μμ  λ¬Έμ  μ½”λ“
```kotlin
// Interfaces/Task1.kt  
package interfacesExercise1  
import atomictest.eq  
  
interface Computer {  
  fun calculateAnswer(): Int  
}  
  
class Cloud(n: Int) : Computer {  
  private val nodes = List(n) { Node(it) }  
  
  override fun calculateAnswer(): Int {  
    return nodes.sumOf { it.calculateAnswer() }  
  }  
}  
  
data class Node(  
  private val result: Int  
) : Computer {  
  override fun calculateAnswer(): Int {  
    return result  
  }  
}  
  
fun main() {  
  Cloud(10).calculateAnswer() eq 45  
}
```
1. `Node` ν΄λμ¤κ°€ `Computer` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ„λ΅ μμ •
2. `Cloud` ν΄λμ¤κ°€ `Computer` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ„λ΅ μμ •
3. `Cloud` ν΄λμ¤ λ‚΄μ— `Node` κ°μ²΄λ“¤μ λ¦¬μ¤νΈλ¥Ό λ§λ“ λ‹¤.
4. κ° ν΄λμ¤μ—μ„ `calculateAnswer()` λ©”μ„λ“λ¥Ό κµ¬ν„
#### μ½”λ“ μ„¤λ…:
- `Node` ν΄λμ¤λ” `Computer` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„(`: Computer`)ν•κ³ , `calculateAnswer()` λ©”μ„λ“λ” κ°„λ‹¨ν `result` κ°’μ„ λ°ν™
- `Cloud` ν΄λμ¤ μ—­μ‹ `Computer` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ‹¤.
    - μƒμ„±μμ—μ„ `n`μ„ λ§¤κ°λ³€μλ΅ λ°›κ³ , μ΄λ¥Ό μ΄μ©ν•΄ `n`κ°μ `Node` κ°μ²΄λ¥Ό λ‹΄μ€ λ¦¬μ¤νΈλ¥Ό μƒμ„±
    - `List(n) { i -> Node(i) }`λ” 0λ¶€ν„° n-1κΉμ§€μ μΈλ±μ¤λ¥Ό μ΄μ©ν•΄ κ°κ° `Node(0)`, `Node(1)`, ..., `Node(n-1)`μ„ λ§λ“¤μ–΄ λ¦¬μ¤νΈμ— λ‹΄λ”λ‹¤.
### μΈν„°νμ΄μ¤ μ‚¬μ© μ΄μ 
- **μΌκ΄€λ λ™μ‘ λ³΄μ¥**: `Computer` μΈν„°νμ΄μ¤λ” ν•΄λ‹Ή μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν• λ¨λ“  ν΄λμ¤κ°€ `calculateAnswer()` λ©”μ„λ“λ¥Ό λ°λ“μ‹ κ°€μ§€κ³  μλ„λ΅ λ³΄μ¥ν•λ‹¤.
- **μ½”λ“ μ μ—°μ„±**: λ‹¤μ–‘ν• ν΄λμ¤λ“¤(`Cloud`μ™€ `Node`)μ΄ κ°™μ€ μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•¨μΌλ΅μ¨, μ΄λ“¤μ„ λ™μΌν• νƒ€μ…μΌλ΅ μ·¨κΈ‰ν•  μ μμµλ‹λ‹¤. μ΄λ” μ½”λ“λ¥Ό λ” μ μ—°ν•κ² λ§λ“ λ‹¤.
- **λ‹¤ν•μ„± ν™μ©**: μ„λ΅ λ‹¤λ¥Έ ν΄λμ¤λ“¤(`Cloud`μ™€ `Node`)μ΄ `calculateAnswer()`λ¥Ό κ°μμ λ°©μ‹μΌλ΅ κµ¬ν„ν•  μ μλ‹¤. μ΄κ²ƒμ΄ λ‹¤ν•μ„±μ ν•µμ‹¬μ΄λ‹¤.

**π“• μ•„ν† λ―Ή μ½”ν‹€λ¦° μ°Έκ³ :**
- 55 μΈν„°νμ΄μ¤
- 62 λ‹¤ν•μ„±
- 63 ν•©μ„±

## SAM λ³€ν™
**λ‹¨μΌ μ¶”μƒ λ©”μ„λ“ μΈν„°νμ΄μ¤**λ” μλ°” κ°λ…μΌλ΅, μλ°”μ—μ„λ” λ©¤λ²„ ν•¨μλ¥Ό 'λ©”μ„λ“'λΌκ³  λ¶€λ¥Έλ‹¤.
μ½”ν‹€λ¦°μ—λ” SAM μΈν„°νμ΄μ¤λ¥Ό μ •μν•λ” `fun interface`λΌλ” νΉλ³„ν• λ¬Έλ²•μ΄ μλ”°.

### μ±…μ μμ 
```kotlin
fun interface ZeroArg {  
  fun f(): Int  
}
```

```kotlin
// Interfaces/SAMImplementation.kt  
package interfaces  
import atomictest.eq  
  
class VerboseZero : ZeroArg {  
  override fun f() = 11  
}  
  
val verboseZero = VerboseZero()  
  
val samZero = ZeroArg { 11 }  
  
class VerboseOne : OneArg {  
  override fun g(n: Int) = n + 47  
}  
  
val verboseOne = VerboseOne()  
  
val samOne = OneArg { it + 47 }  
  
class VerboseTwo : TwoArg {  
  override fun h(i: Int, j: Int) = i + j  
}  
  
val verboseTwo = VerboseTwo()  
  
val samTwo =  TwoArg { i, j -> i + j }  
  
fun main() {  
  verboseZero.f() eq 11  
  samZero.f() eq 11  
  verboseOne.g(92) eq 139  
  samOne.g(92) eq 139  
  verboseTwo.h(11, 47) eq 58  
  samTwo.h(11, 47) eq 58  
}
```

μμ  μ½”λ“λ¥Ό λ³΄λ©΄:
1. **VerboseZero** ν΄λμ¤λ” **ZeroArg** μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•κ³  μκ³ ,
2. **samZero**λ” λλ‹¤λ¥Ό μ‚¬μ©ν•΄ κ°™μ€ μΈν„°νμ΄μ¤λ¥Ό λ” κ°„κ²°ν•κ² κµ¬ν„

μ¦‰:
```kotlin
class VerboseZero : ZeroArg {  
  override fun f() = 11  
}
```

```kotlin
val samZero = ZeroArg { 11 }
```
μ„ λ‘ μ½”λ“λ” λ™μΌν• κΈ°λ¥μ„ ν•μ§€λ§ ν‘ν„ λ°©μ‹λ§ λ‹¤λ¥΄λ‹¤.

**μ²« λ²μ§Έ μ½”λ“**λ” μ „ν†µμ μΈ λ°©μ‹μΌλ΅:
- ZeroArg μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” VerboseZero ν΄λμ¤λ¥Ό μ •μ
- `f()` λ©”μ„λ“λ¥Ό μ¤λ²„λΌμ΄λ“ν•μ—¬ 11μ„ λ°ν™ν•λ„λ΅ κµ¬ν„
- κ·Έ ν΄λμ¤μ μΈμ¤ν„΄μ¤λ¥Ό veroseZero λ³€μμ— ν• λ‹Ή
  **λ‘ λ²μ§Έ μ½”λ“**λ” SAM λ³€ν™μ„ μ‚¬μ©ν•΄μ„:
- ZeroArg μΈν„°νμ΄μ¤μ μ μΌν• μ¶”μƒ λ©”μ„λ“ `f()` λ¥Ό λλ‹¤ `{ 11 }` λ΅ κµ¬ν„
- κ·Έ κµ¬ν„μ²΄λ¥Ό λ°”λ΅ samZero λ³€μμ— ν• λ‹Ή

μ½”ν‹€λ¦° μ»΄νμΌλ¬λ” λ‚΄λ¶€μ μΌλ΅ μ΄ λλ‹¤λ¥Ό ZeroArg μΈν„°νμ΄μ¤μ κµ¬ν„μ²΄λ΅ λ³€ν™ν•λ‹¤. κ²°κ³Όμ μΌλ΅ λ‘ μ½”λ“ λ¨λ‘ `f()`λ©”μ„λ“λ¥Ό νΈμ¶ν–μ„ λ• 11μ„ λ°ν™ν•λ” ZeroArg μΈν„°νμ΄μ¤λ¥Ό λ§λ“ λ‹¤.

`main()`ν•¨μμ—μ„ λ³Ό μ μλ“―, λ‘ κ°μ²΄μ λ™μ‘μ€ μ™„μ „ λ™μΌ:
```kotlin
verboseZero.f() eq 11
samZero.f() eq 11
```

### AtomicKotlinCourseμ μμ  λ¬Έμ 
```kotlin
// Interfaces/Task2.kt  
package interfacesExercise2  
import atomictest.eq  
  
interface Pet {  
  fun speak(): String  
}  
  
class Dog: Pet {  
  override fun speak(): String = "Bark!"  
}  
  
  
class Cat: Pet {  
  override fun speak(): String = "Meow!"  
}
```
μ„μ μμ λ¥Ό λ‹¤μκ³Ό κ°™μ΄ λ³€κ²½ν•  μ μμ

```kotlin
// Interfaces/Task2.kt  
package interfacesExercise2  
import atomictest.eq  
  
fun interface Pet {  
  fun speak(): String  
}  

val dog = Pet { "Bark!" }
  
val cat = Pet { "Meow!" }

```

### Todo μ•±μ—μ„ SAM λ³€ν™ μ‚¬μ©ν•κΈ°
```kotlin
// Todo ν•„ν„°λ§ μΈν„°νμ΄μ¤
fun interface TodoFilter {
    fun matches(todo: Todo): Boolean
}
```
μ΄κ²ƒμ€ ν•λ‚μ μ¶”μƒ λ©”μ„λ“ (matches)λ¥Ό κ°€μ§„ μΈν„°νμ΄μ¤.

#### findTodos λ©”μ„λ“μ™€ μ‚¬μ©λ²•
```kotlin
class TodoManager {
	private val todos = mutableListOf<Todo>()
	
	// ν•„ν„°λ¥Ό ν†µν•΄ ν•  μΌ μ°ΎκΈ°
	fun findTodos(filter: TodoFilter): List<Todo> {
		return todos.filter { filter.matches(it) }
	}
}
```

#### μ „ν†µμ μΈ λ°©μ‹ (override μ‚¬μ©)
```kotlin
class CompletedFilter: TodoFilter {
	override fun matches(todo: Todo): Boolean {
		return todo.isCompleted
	}
}

val completed1 = findTodos(CompletedFilter())
```
μ—¬κΈ°μ„ `override`κ°€ ν•„μ”ν• μ΄μ :
- `CompletedFilter`ν΄λμ¤κ°€ `TodoFilter`μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•κΈ° λ•λ¬Έ
- μΈν„°νμ΄μ¤μ λ©”μ„λ“λ¥Ό κµ¬ν„ν•  λ•λ” ν•­μƒ `override`ν‚¤μ›λ“λ¥Ό μ‚¬μ©

#### SAM λ³€ν™ μ‚¬μ© (override μ—†μ)
```kotlin
val completed2 = findTodos(TodoFilter { todos -> todo.isCompleted })
```
μ—¬κΈ°μ„λ” `override`ν‚¤μ›λ“κ°€ ν•„μ”ν•μ§€ μ•μ:
- μ»΄νμΌλ¬κ°€ λλ‹¤λ¥Ό μλ™μΌλ΅ `TodoFilter`μΈν„°νμ΄μ¤μ κµ¬ν„μ²΄λ΅ λ³€ν™
- λλ‹¤κ°€ μ§μ ‘ `matches`λ©”μ„λ“μ  κµ¬ν„μ΄ λλ―€λ΅ `override`ν‚¤μ›λ“ ν•„μ” μ—†μ
#### λ” κ°„κ²°ν• λ°©μ‹ (νƒ€μ… μ¶”λ΅ )
```kotlin
val completed3 = findTodos { todo -> todo.isCompleted }
```
μ΄ λ°©μ‹μ€ μ»΄νμΌλ¬κ°€ μ»¨ν…μ¤νΈμ—μ„ ν•„μ”ν• νƒ€μ…μ„ μ¶”λ΅ ν•  μ μμ„ λ• κ°€λ¥.
`findTodos` λ©”μ„λ“κ°€ `TodoFilter` νƒ€μ…μ λ§¤κ°λ³€μλ¥Ό κΈ°λ€ν•λ―€λ΅, μ»΄νμΌλ¬λ” λλ‹¤λ¥Ό μλ™μΌλ΅ `TodoFilter` νƒ€μ…μΌλ΅ λ³€ν™ν•λ‹¤.



